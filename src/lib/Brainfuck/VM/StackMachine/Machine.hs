{-# LANGUAGE GeneralizedNewtypeDeriving, TypeSynonymInstances, FlexibleInstances #-}


module Brainfuck.VM.StackMachine.Machine  (execVM,runProgram,runProgramSingle,VM,MachineState(..),initMachine,Program,LogMessages,VMError(..),programFromList)
where

-- this is the implementation of a stack-machine with an accumulator that interprets the
-- bytecode that has been generated by the compiler

import Brainfuck.Compiler.Backend.CodeGeneration.VM.StackMachine.Assembly
import qualified Data.IntMap as IMap
import qualified Data.DList as DL
import Data.Char
import Data.Array.IArray
import Control.Monad.RWS
import Control.Monad.State
import Control.Monad.Error
import Data.Maybe (fromJust)
import System.IO (stdout,stdin,hFlush)

-- Logging support
type LogMessages = DL.DList String

instance Show LogMessages where
    show = show . DL.toList

jot :: String -> VM ()
jot message = tell (DL.singleton message)

-- The machine state and monad
type Stack       = [Int]
type Program     = Array Int Instruction
type MainMemory  = IMap.IntMap Int

data MachineState = MachineState {
      vmStack    :: Stack,      -- the arithmetic stack
      vmData     :: MainMemory, -- the data segment
      vmDataSize :: Int,        -- the size of the data segment
      rMp        :: Int,        -- the memory pointer
      rIp        :: Int,        -- instruction pointer
      rAcc       :: Int         -- accumulator
    } deriving(Eq,Show)

data VMError = GenericError String
             | StackError  MachineState
             | MemoryError MachineState
               deriving (Eq,Show)

instance Error VMError where
     noMsg    = GenericError "unknown"
     strMsg s = GenericError s

newtype VM a = VM {
      runVM :: ErrorT VMError (RWST Program LogMessages MachineState IO) a
} deriving (Functor, Applicative, Monad,MonadIO, MonadError VMError, MonadReader Program, MonadWriter LogMessages, MonadState MachineState)

programFromList :: [Instruction] -> Program
programFromList instrs = listArray (0,(length instrs) - 1) instrs

initMachine :: Int -> MachineState
initMachine memsize = MachineState{ vmStack = [], vmData = IMap.empty, vmDataSize = memsize, rIp = 0, rAcc = 0, rMp = 0 }

-- Example: execVM program (initMachine 30000) runProgram
execVM :: Program -> MachineState -> VM a -> IO (Either (VMError,MachineState,LogMessages) (MachineState,LogMessages,a))
execVM program state action = do
    result <- runRWST (runErrorT (runVM action)) program state
    case result of
      ((Left err),state,logs)    -> return $ Left  (err,state,logs)
      ((Right value),state,logs) -> return $ Right (state,logs,value)

debugPrint :: String -> VM ()
debugPrint str = liftIO $ print $ str

rip :: VM Int
rip = get >>= return . rIp

modifyIp :: (Int -> Int) -> VM ()
modifyIp f = modify(\s -> s{ rIp = (f $ rIp s) })

incIp :: VM ()
incIp = modifyIp (1+)

racc :: VM Int
racc = get >>= return . rAcc

modifyAcc :: (Int -> Int) -> VM ()
modifyAcc f = modify(\s -> s{ rAcc = (f $ rAcc s)})

setAcc :: Int -> VM ()
setAcc v = modifyAcc(\_ -> v)

rmp :: VM Int
rmp = get >>= return . rMp

modifyMp :: (Int -> Int) -> VM ()
modifyMp f = modify(\s -> s{ rMp = (f $ rMp s)})

setMp :: Int -> VM ()
setMp v = modifyMp(\_ -> v)

-- memory management
loadWord :: Int -> VM Int
loadWord addr = do
  state <- get
  let maxaddr = (vmDataSize state)
  if addr > maxaddr then
      error $ "MemoryError: Can not read memory at address: " ++ (show addr)
  else
      return $ (IMap.findWithDefault 0 addr (vmData state))

storeWord :: Int -> Int -> VM ()
storeWord addr value = do
    state <- get
    let maxaddr = (vmDataSize state)
    if addr > maxaddr then
        error $ "MemoryError: Can not write memory at address: " ++ (show addr)
    else
        put state{ vmData=(IMap.insert addr value (vmData state)) }

-- data stack management
push :: Int -> VM ()
push value = modify (\s -> s{ vmStack=value:(vmStack s) })

pop :: VM Int
pop = do
  state <- get
  let stack = vmStack state
  case stack of
    []         -> error "StackError: Can not pop empty stack"
    (top:rest) -> do
               put state{ vmStack = rest }
               return top

runProgram :: VM ()
runProgram = fetchInstruction >>= execInstruction

-- run program in single step mode
runProgramSingle :: VM ()
runProgramSingle = do
  state <- get
  ip    <- rip
  accu  <- racc
  mp    <- rmp
  instr <- fetchInstruction
  liftIO $ putStr $ "Instr: " ++ (show instr) ++ " Ip: " ++ (show ip) ++ " Mp: " ++ (show mp) ++ " Accu: " ++ (show accu) ++ " Stack: " ++ (show (vmStack state)) ++ "\n"
  liftIO $ putStr $ "========================================================================================================================================================\n"
  printProgramExcerpt
  liftIO $ putStr "\n"
  inp   <- liftIO getLine
  case inp of
    "break" -> return ()
    _       -> execInstructionSingle instr


-- returns an excerpt of the program
programExcerpt :: VM [(Instruction,Int)]
programExcerpt = do
  program <- ask
  ip      <- rip
  let (lower,upper) = sizer ip 10
  return $ programSlice program lower upper
    where
      sizer :: Int -> Int -> (Int,Int)
      sizer curip amount =
          if amount > curip then
              (0,(curip + amount))
          else
              ((curip - amount),(curip + amount))

programSlice :: Program -> Int -> Int -> [(Instruction,Int)]
programSlice prog from to = [(prog ! i,i) | i <- [from .. to]]

printProgramExcerpt :: VM ()
printProgramExcerpt = do
  ip     <- rip
  instrs <- programExcerpt
  liftIO $ putStr $ unlines $ map (formatProgramLine ip) instrs
    where
      formatProgramLine :: Int -> (Instruction,Int) -> String
      formatProgramLine curip (instr,ip) =
          if curip == ip then
              (show ip) ++ " > " ++ (toMnemonic instr)
          else
              (show ip) ++ "   " ++ (toMnemonic instr)

execInstructionSingle :: Maybe Instruction -> VM ()
execInstructionSingle Nothing  = do
  liftIO $ putStr $ "HALT\n"
  return ()

execInstructionSingle (Just i) = execInstruction' i >> runProgramSingle

execInstruction :: Maybe Instruction -> VM ()
execInstruction Nothing  = jot "Halt" >> return ()
execInstruction (Just i) = execInstruction' i >> runProgram

fetchInstruction :: VM (Maybe Instruction)
fetchInstruction = do
  code <- ask
  ip   <- rip
  let (_,size) = bounds code
  return $ fetch ip size code
    where
      fetch ip size code
          | ip > size = Nothing
          | otherwise = Just $ code ! ip

execInstruction' :: Instruction -> VM ()
execInstruction' Nop        = instrNop
execInstruction' (Li value) = instrLi value
execInstruction' Lp         = instrLp
execInstruction' Sp         = instrSp
execInstruction' Psh        = instrPsh
execInstruction' Add        = instrAdd
execInstruction' Lw         = instrLw
execInstruction' Sw         = instrSw
execInstruction' In         = instrIn
execInstruction' Out        = instrOut
execInstruction' Jz         = instrJz
execInstruction' Jnz        = instrJnz

-- does nothing
instrNop :: VM ()
instrNop = incIp

-- $acc ...
-- stack [..]
-- load immediate word into $acc
-- $acc word
-- stack [..]
instrLi :: Int -> VM ()
instrLi val = setAcc val >> incIp

-- $acc ...
-- stack [..]
-- load $mp into $acc
-- $acc $mp
-- stack [..]

instrLp :: VM ()
instrLp = do
  mp <- rmp
  setAcc mp >> incIp


-- $acc val
-- stack [..]
-- stores the value of $acc in $mp
-- $acc  val
-- stack [..]

instrSp :: VM ()
instrSp = do
  acc <- racc
  setMp acc >> incIp

-- $acc value
-- stack [..]
-- pushes value to stack
-- $acc value
-- stack [..,value]
instrPsh :: VM ()
instrPsh = do
  val <- racc
  push val >> incIp


-- $acc   y
-- stack [..,x]
-- call
-- $acc   result
-- stack [..]
instrAdd :: VM ()
instrAdd = do
  x <- pop
  modifyAcc (x+)
  incIp

-- TODO: error handling
-- $acc   address
-- stack [..]
-- reads value at address
-- $acc   value
-- stack [..]
instrLw :: VM ()
instrLw = do
    addr <- racc
    word <- loadWord addr
    setAcc word
    incIp


-- TODO: error handling
-- $acc   address
-- stack [..,value]
-- stores value at address in main memory
-- $acc   address
-- stack []
instrSw :: VM ()
instrSw = do
  addr    <- racc
  value   <- pop
  storeWord addr value >> incIp

-- $acc  _
-- stack [..]
-- reads one char from stdin
-- $acc  word
-- stack [..]
instrIn :: VM ()
instrIn = do
  val <- liftIO getChar
  setAcc $ ord val
  incIp

-- $acc  word
-- stack [..]
-- writes value out
-- $acc  word
-- stack [..]
instrOut :: VM ()
instrOut = do
  addr <- racc
  writeChar addr >> incIp
    where writeChar val = do
             liftIO $ putChar $ chr val
             liftIO $ hFlush  $ stdout

-- $acc  offset
-- stack [..,value]
-- jumps to target address if value is zero
-- $acc  offset
-- stack [..]
instrJz :: VM ()
instrJz = do
  addr    <- racc
  value   <- pop
  case value of
    0 -> modifyIp (+addr)
    _ -> incIp

-- $acc offset
-- stack [..,value]
-- jumps to target address if value is not zero
-- $acc offset
-- stack [..]
instrJnz :: VM ()
instrJnz = do
  addr    <- racc
  value   <- pop
  case value of
    0 -> incIp
    _ -> modifyIp (+addr)
